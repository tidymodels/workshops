{
  "hash": "a71e0249458d5e4962932543e20dfd61",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Extras - Effect Encodings\"\nsubtitle: \"Advanced tidymodels\"\nformat:\n  revealjs: \n    slide-number: true\n    footer: <https://workshops.tidymodels.org>\n    include-before-body: header.html\n    include-after-body: footer-annotations.html\n    theme: [default, tidymodels.scss]\n    width: 1280\n    height: 720\nknitr:\n  opts_chunk: \n    echo: true\n    collapse: true\n    comment: \"#>\"\n    fig.path: \"figures/\"\n---\n\n\n\n\n\n\n\n## Previously - Setup\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(textrecipes)\nlibrary(bonsai)\n\n# Max's usual settings: \ntidymodels_prefer()\ntheme_set(theme_bw())\noptions(\n  pillar.advice = FALSE, \n  pillar.min_title_chars = Inf\n)\n```\n:::\n\n\n\n:::\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(hotel_rates)\nset.seed(295)\nhotel_rates <- \n  hotel_rates %>% \n  sample_n(5000) %>% \n  arrange(arrival_date) %>% \n  select(-arrival_date) %>% \n  mutate(\n    company = factor(as.character(company)),\n    country = factor(as.character(country)),\n    agent = factor(as.character(agent))\n  )\n```\n:::\n\n\n\n\n:::\n\n::::\n\n\n## Previously - Data Usage\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(4028)\nhotel_split <-\n  initial_split(hotel_rates, strata = avg_price_per_room)\n\nhotel_train <- training(hotel_split)\nhotel_test <- testing(hotel_split)\n\nset.seed(472)\nhotel_rs <- vfold_cv(hotel_train, strata = avg_price_per_room)\n```\n:::\n\n\n\n\n## What do we do with the agent and company data? \n\nThere are 98 unique agent values and 100 companies in our training set. How can we include this information in our model?\n\n. . .\n\nWe could:\n\n-   make the full set of indicator variables ðŸ˜³\n\n-   lump agents and companies that rarely occur into an \"other\" group\n\n-   use [feature hashing](https://www.tmwr.org/categorical.html#feature-hashing) to create a smaller set of indicator variables\n\n-   use effect encoding to replace the `agent` and `company` columns with the estimated effect of that predictor\n\n\n\n\n\n\n\n\n\n\n## Per-agent statistics {.annotation}\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/effects-freq-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/effects-adr-1.svg){fig-align='center' width=90%}\n:::\n:::\n\n\n:::\n:::\n\n\n## What is an effect encoding?\n\nWe replace the qualitativeâ€™s predictor data with their _effect on the outcome_. \n\n::: columns\n::: {.column width=\"50%\"}\nData before:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbefore\n#> # A tibble: 7 Ã— 3\n#>   avg_price_per_room agent            .row\n#>                <dbl> <fct>           <int>\n#> 1               52.7 cynthia_worsley     1\n#> 2               51.8 carlos_bryant       2\n#> 3               53.8 lance_hitchcock     3\n#> 4               51.8 lance_hitchcock     4\n#> 5               46.8 cynthia_worsley     5\n#> 6               54.7 charles_najera      6\n#> 7               46.8 cynthia_worsley     7\n```\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\nData after:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nafter\n#> # A tibble: 7 Ã— 3\n#>   avg_price_per_room agent  .row\n#>                <dbl> <dbl> <int>\n#> 1               52.7  88.5     1\n#> 2               51.8  89.5     2\n#> 3               53.8  79.8     3\n#> 4               51.8  79.8     4\n#> 5               46.8  88.5     5\n#> 6               54.7 109.      6\n#> 7               46.8  88.5     7\n```\n:::\n\n\n\n:::\n:::\n\nThe `agent` column is replaced with an estimate of the ADR. \n\n\n## Per-agent statistics again \n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/effects-again-1.svg){fig-align='center' width=90%}\n:::\n\n::: {.cell-output-display}\n![](figures/effects-again-2.svg){fig-align='center' width=90%}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n- Good statistical methods for estimating these means use *partial pooling*.\n\n\n- Pooling borrows strength across agents and shrinks extreme values towards the mean for agents with very few transations\n\n\n- The embed package has recipe steps for effect encodings.\n\n:::\n:::\n\n\n:::notes\nPartial pooling gives better estimates for agents with fewer reservations by shrinking the estimate to the overall ADR mean\n\n\n:::\n\n## Partial pooling\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/effect-compare-1.svg){fig-align='center'}\n:::\n:::\n\n\n\n## Agent effects ![](hexes/recipes.png){.absolute top=-20 right=0 width=\"64\" height=\"74.24\"} ![](hexes/embed.png){.absolute top=-20 right=64 width=\"64\" height=\"74.24\"} {.annotation}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1,6|\"}\nlibrary(embed)\n\nhotel_effect_rec <-\n  recipe(avg_price_per_room ~ ., data = hotel_train) %>% \n  step_YeoJohnson(lead_time) %>%\n  step_lencode_mixed(agent, company, outcome = vars(avg_price_per_room)) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_zv(all_predictors())\n```\n:::\n\n\n\n. . .\n\nIt is very important to appropriately validate the effect encoding step to make sure that we are not overfitting.\n\n## Effect encoding results ![](hexes/workflows.png){.absolute top=-20 right=0 width=\"64\" height=\"74.24\"} ![](hexes/tune.png){.absolute top=-20 right=64 width=\"64\" height=\"74.24\"} ![](hexes/recipes.png){.absolute top=-20 right=128 width=\"64\" height=\"74.24\"} ![](hexes/embed.png){.absolute top=-20 right=192 width=\"64\" height=\"74.24\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4|\"}\nhotel_effect_wflow <-\n  workflow() %>%\n  add_model(linear_reg()) %>% \n  update_recipe(hotel_effect_rec)\n\nreg_metrics <- metric_set(mae, rsq)\n\nhotel_effect_res <-\n  hotel_effect_wflow %>%\n  fit_resamples(hotel_rs, metrics = reg_metrics)\n\ncollect_metrics(hotel_effect_res)\n#> # A tibble: 2 Ã— 6\n#>   .metric .estimator   mean     n std_err .config             \n#>   <chr>   <chr>       <dbl> <int>   <dbl> <chr>               \n#> 1 mae     standard   17.8      10 0.189   Preprocessor1_Model1\n#> 2 rsq     standard    0.870    10 0.00357 Preprocessor1_Model1\n```\n:::\n\n\n\nSlightly worse but it can handle new agents (if they occur).\n\n\n\n\n",
    "supporting": [
      "extras-effect-encodings_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}